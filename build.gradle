plugins {
    id "architectury-plugin" version "3.4-SNAPSHOT"
    id "dev.architectury.loom" version "1.5-SNAPSHOT" apply false
    id "io.github.pacifistmc.forgix" version "1.2.6"
    id "org.ajoberstar.grgit" version "4.1.0"
    id "systems.manifold.manifold-gradle-plugin" version "0.0.2-alpha"
}

import groovy.json.JsonSlurper

import java.security.MessageDigest

def writeBuildGradlePredefine(List<String> mcVers, int mcIndex) {
    // Build the list of preprocessors to use
    StringBuilder sb = new StringBuilder();

    sb.append("# DON'T TOUCH THIS FILE, This is handled by the build script\n");

    for (int i = 0; i < mcVers.size(); i++) {
        String verStr = mcVers[i].replace(".", "_");
        sb.append("MC_" + verStr + "=" + i.toString() + "\n");

        if (mcIndex == i)
            sb.append("MC_VER=" + i.toString() + "\n");
    }

    new File(projectDir, "build.properties").text = sb.toString()
}

static def generateForgeVersions(mc_versions) {
    def json = new JsonSlurper().parseText(mc_versions) as List<String>
    if (json.size() == 0) {
        throw new Exception("error invalid version list")
    }
    def lastItem = json[json.size() - 1]
    def lastItemSplit = lastItem.split("\\.")
    if (lastItemSplit.size() != 3) {
        throw new Exception("error invalid version number: " + lastItem)
    }
    lastItemSplit[lastItemSplit.size() - 1] = (lastItemSplit[lastItemSplit.size() - 1].toInteger() + 1).toString()
    def topBound = lastItemSplit.join(".")
    return "[" + json[0] + "," + topBound + ")"
}

project.gradle.ext.getProperties().each { prop ->
    rootProject.ext.set(prop.key, prop.value)
}
writeBuildGradlePredefine(rootProject.mcVers, rootProject.mcIndex)

rootProject.versionStr = "${rootProject.mod_version}-mc${rootProject.minecraft_version}"
rootProject.compatible_forge_versions = generateForgeVersions(rootProject.compatible_minecraft_versions)
rootProject.forgix_merged_jar = "${project.archives_base_name}-${rootProject.versionStr}-${getVersionMetadata()}.jar"

compileJava {
    sourceCompatibility = rootProject.java_version
    targetCompatibility = rootProject.java_version
}

architectury {
    minecraft = rootProject.minecraft_version
}

import net.fabricmc.tinyremapper.NonClassCopyMode
import net.fabricmc.tinyremapper.OutputConsumerPath
import net.fabricmc.tinyremapper.TinyRemapper
import net.fabricmc.tinyremapper.TinyUtils

import java.nio.file.Files
import java.nio.file.StandardCopyOption
import java.security.MessageDigest

var mappingsProjectDir = project(":mappings").projectDir.toPath()
var mappingsTinyFile = new File(mappingsProjectDir.resolve("arch_${rootProject.architectury_version}.tiny").toUri())
var hashHex = HexFormat.of().formatHex(MessageDigest.getInstance("SHA-1").digest(mappingsTinyFile.readBytes()))

static void runMappingsOnJar(File input, File output, File mappingsTiny, String fromM, String toM) {
    def remapper = TinyRemapper.newRemapper()
            .withMappings(TinyUtils.createTinyMappingProvider(mappingsTiny.toPath(), fromM, toM))
            .renameInvalidLocals(false)
            .build()

    output.delete()

    try (OutputConsumerPath outputConsumer = new OutputConsumerPath.Builder(output.toPath()).build()) {
        outputConsumer.addNonClassFiles(input.toPath(), NonClassCopyMode.FIX_META_INF, remapper)
        remapper.readInputs(input.toPath())
        remapper.readClassPath(input.toPath())
        remapper.apply(outputConsumer)
    } catch (IOException e) {
        throw new RuntimeException(e)
    } finally {
        remapper.finish()
    }
}

subprojects { p ->
    apply plugin: "java"
    apply plugin: "dev.architectury.loom"
    apply plugin: "systems.manifold.manifold-gradle-plugin"

    loom {
        silentMojangMappingsLicense()
    }

    // set up custom configurations (configurations are a way to handle dependencies)
    configurations {
        compile
        mappings
        addArchApi

        // extends the shadowJar configuration
        shadowMe
        // have implemented dependencies automatically embedded in the final jar
        implementation.extendsFrom(shadowMe)

        forgeShadowMe
        implementation.extendsFrom(forgeShadowMe)
        shadowMe.extendsFrom(forgeShadowMe)
        forgeRuntimeLibrary.extendsFrom(forgeShadowMe)

        if (p != project(":common")) {
            // Shadow common
            common
            shadowCommon // Don't use shadow from the shadow plugin because we don't want IDEA to index this.
            compileClasspath.extendsFrom common
            runtimeClasspath.extendsFrom common
            if (findProject(":forge"))
                developmentForge.extendsFrom common
            if (findProject(":neoforge"))
                developmentNeoForge.extendsFrom common
            compileClasspath.extendsFrom coreProjects
            runtimeClasspath.extendsFrom coreProjects
            if (findProject(":forge"))
                developmentForge.extendsFrom coreProjects
            if (findProject(":neoforge"))
                developmentNeoForge.extendsFrom coreProjects
        }
    }

    String platformStr = ""
    if (findProject(":common") && p != project(":common")) {
        if (findProject(":quilt") && p == project(":quilt")) platformStr = "-fabric"
        else platformStr = "-${p.name}"
    }
    File remappedArchFile = new File(rootProject.projectDir, ".gradle/remapped_architectury_cache/${hashHex}/remapped-architectury-${p.name}-${rootProject.architectury_version}.jar")

    dependencies {
        annotationProcessor("systems.manifold:manifold-preprocessor:${rootProject.manifold_version}")

        minecraft "com.mojang:minecraft:${rootProject.minecraft_version}"
        mappings loom.layered() {
            officialMojangMappings()
            parchment("org.parchmentmc.data:parchment-${rootProject.parchment_version}@zip")
        }

        if (p.name == "quilt") {
            addArchApi("${rootProject.architectury_group}:architectury-fabric:${rootProject.architectury_version}") {
                exclude group: "net.fabricmc"
                exclude group: "net.fabricmc.fabric-api"
            }
        } else {
            addArchApi "${rootProject.architectury_group}:architectury${platformStr}:${rootProject.architectury_version}"
        }

        if (p != project(":common")) {
            common(project(path: ":common", configuration: "namedElements")) { transitive false }
            shadowCommon(project(path: ":common", configuration: "transformProduction${capitalProject(p.name)}")) { transitive false }
        }

        if (findProject(":mappings") && p != project(":mappings")) {
            dependencies {
                modApi files(remappedArchFile.toPath())
            }
        }
    }

    repositories {
        maven { url "https://maven.shedaniel.me/" }
    }

    if (findProject(":mappings") && p != project(":mappings")) {
        tasks.register('applyMappings') {
            if (!remappedArchFile.exists()) {
                var archJarPath = "/architectury${platformStr}-${rootProject.architectury_version}.jar"
                println "Searching for architectury jar: $archJarPath"

                File archJar = configurations.addArchApi.files.find { it.path.endsWith(archJarPath) }
                println "Found matching jar: ${archJar.name}"
                println "Using mappings: ${mappingsTinyFile.name}"

                runMappingsOnJar(archJar, remappedArchFile, mappingsTinyFile, "official", "named")

                println "Remapping completed successfully."
            }
            return
        }

        compileJava.dependsOn applyMappings

        tasks.register('undoApplyMappings') {
            doLast {
                File mergedJar = new File(rootProject.layout.projectDirectory.asFile, "Merged/${rootProject.forgix_merged_jar}")
                if (!mergedJar.exists()) throw new GradleException("Missing merged output jar")
                File remapFile = new File(mergedJar.parentFile, mergedJar.name + ".remapped.jar")
                runMappingsOnJar(mergedJar, remapFile, mappingsTinyFile, "named", "official")
                mergedJar.delete()
                Files.copy(remapFile.toPath(), mergedJar.toPath(), StandardCopyOption.REPLACE_EXISTING)
                remapFile.delete()
            }
        }

        rootProject.tasks['mergeJars'].finalizedBy undoApplyMappings
    }
}

static def capitalProject(String value) {
    if (value == "neoforge") return "NeoForge"
    return value[0].toUpperCase() + value.substring(1)
}

allprojects {
    apply plugin: "java"
    apply plugin: "architectury-plugin"
    apply plugin: "maven-publish"

    archivesBaseName = "${rootProject.archives_base_name}-${project.name}"
    version = rootProject.versionStr
    group = rootProject.maven_group

    repositories {
        // Add repositories to retrieve artifacts from in here.
        // You should only use this when depending on other mods because
        // Loom adds the essential maven repositories to download Minecraft and libraries from automatically.
        // See https://docs.gradle.org/current/userguide/declaring_repositories.html
        // for more information about repositories.
        maven { url "https://maven.shedaniel.me/" }
        maven { url "https://maven.terraformersmc.com/releases/" }
        maven { url "https://maven.parchmentmc.org" }
    }

    tasks.withType(JavaCompile) {
        options.encoding = "UTF-8"
        options.release = rootProject.java_version as Integer
        options.compilerArgs += ["-Xplugin:Manifold"]
    }

    processResources {
        exclude { file ->
            if (file.name.contains(".${mod_id}.accesswidener") && file.name != "${accessWidenerVersion}.${mod_id}.accesswidener") {
                return true
            }
            return false
        }
    }

    java {
        withSourcesJar()
    }

    publishing {
        repositories {
            maven {
                credentials {
                    username = "melon"
                    password = System.getenv("MAVEN_PASS")
                }
                switch (System.getenv("MAVEN_TYPE")) {
                    case "production": url = "https://maven.mrmelon54.com/releases"; break
                    case "development": url = "http://localhost:8080/snapshots"; break
                    default: url = "https://maven.mrmelon54.com/snapshots"; break
                }
            }
        }
    }
}

forgix {
    group = "com.mrmelon54.infrastructury"
    mergedJarName = rootProject.forgix_merged_jar

    if (findProject(":fabric"))
        fabric {
            jarLocation = "build/libs/${project.archives_base_name}-fabric-${rootProject.versionStr}.jar"
        }

    if (findProject(":quilt"))
        quilt {
            jarLocation = "build/libs/${project.archives_base_name}-quilt-${rootProject.versionStr}.jar"
        }

    if (findProject(":forge"))
        forge {
            jarLocation = "build/libs/${project.archives_base_name}-forge-${rootProject.versionStr}.jar"
        }

    if (findProject(":neoforge"))
        custom {
            projectName = "neoforge"
            jarLocation = "build/libs/${project.archives_base_name}-neoforge-${rootProject.versionStr}.jar"
        }

    removeDuplicate "com.mrmelon54.infrastructury"
}

def getVersionMetadata() {
    def build_id = System.getenv("GITHUB_RUN_NUMBER")

    // CI builds only
    if (build_id != null) {
        return "build.${build_id}"
    }

    if (grgit != null) {
        def head = grgit.head()
        def id = head.abbreviatedId

        // Flag the build if the build tree is not clean
        if (!grgit.status().clean) {
            id += "-dirty"
        }

        return "rev.${id}"
    }

    // No tracking information could be found about the build
    return "unknown"
}

// Delete the merged folder when running clean
task cleanMergedJars() {
    def mergedFolder = file("Merged")
    if (mergedFolder.exists()) {
        delete(mergedFolder)
    }
}
// add cleanMergedJars to the end of the "clean" task
tasks["clean"].finalizedBy(cleanMergedJars)
